package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"

	"github.com/ishanz23/go-turso-starter-api/graph/model"
)

// CreateLocation is the resolver for the createLocation field.
func (r *mutationResolver) CreateLocation(ctx context.Context, input model.NewLocation) (*model.Location, error) {
	panic(fmt.Errorf("not implemented: CreateLocation - createLocation"))
}

// CreateHomestay is the resolver for the createHomestay field.
func (r *mutationResolver) CreateHomestay(ctx context.Context, input model.NewHomestay) (*model.Homestay, error) {
	panic(fmt.Errorf("not implemented: CreateHomestay - createHomestay"))
}

// CreateRoom is the resolver for the createRoom field.
func (r *mutationResolver) CreateRoom(ctx context.Context, input model.NewRoom) (*model.Room, error) {
	panic(fmt.Errorf("not implemented: CreateRoom - createRoom"))
}

// Locations is the resolver for the locations field.
func (r *queryResolver) Locations(ctx context.Context) ([]*model.Location, error) {
	rows, err := r.DB.Query("SELECT id, name, state, description, lat, long, altitude, coverUrl from location")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	locations := []*model.Location{}
	for rows.Next() {
		location := model.Location{}
		if err := rows.Scan(&location.ID, &location.Name, &location.State, &location.Description, &location.Lat, &location.Long, &location.Altitude, &location.CoverURL); err != nil {
			return nil, err
		}
		locations = append(locations, &location)
	}
	return locations, nil
}

// Homestays is the resolver for the homestays field.
func (r *queryResolver) Homestays(ctx context.Context, locationID *int) ([]*model.Homestay, error) {
	rows, err := r.DB.Query("SELECT homestay.id, homestay.name, homestay.address, location.name, location.description, location.altitude, location.coverUrl, location.lat, location.long, location.state from homestay INNER JOIN location ON homestay.locationId=location.id where location.id = ?", locationID)

	if err != nil {
		return nil, err
	}
	defer rows.Close()
	homestays := []*model.Homestay{}
	for rows.Next() {
		homestay := model.Homestay{Location: &model.Location{ID: 0, Name: nil, Lat: nil, Long: nil, State: nil, Altitude: nil, Description: nil, CoverURL: nil, Homestays: nil}}
		location := model.Location{}
		if err := rows.Scan(&homestay.ID, &homestay.Name, &homestay.Address, &location.Name, &location.Description, &location.Altitude, &location.CoverURL, &location.Lat, &location.Long, &location.State); err != nil {
			return nil, err
		}
		homestay.Location = &location
		homestays = append(homestays, &homestay)
	}
	return homestays, nil
}

// Homestay is the resolver for the homestay field.
func (r *queryResolver) Homestay(ctx context.Context, homestayID int) (*model.Homestay, error) {
	var homestay model.Homestay

	// Query for Homestay
	err := r.DB.QueryRow("SELECT id, name, address FROM homestay WHERE id = ?", homestayID).Scan(
		&homestay.ID,
		&homestay.Name,
		&homestay.Address,
	)
	if err != nil {
		return nil, err
	}

	// Query for associated Rooms
	rows, err := r.DB.Query("SELECT id, name, category, toiletAttached FROM room WHERE homestayId = ?", homestayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// Populate the rooms in the homestay
	for rows.Next() {
		var room model.Room
		if err := rows.Scan(&room.ID, &room.Name, &room.Category, &room.ToiletAttached); err != nil {
			return nil, err
		}
		homestay.Rooms = append(homestay.Rooms, &room)
	}

	return &homestay, nil
}

// Rooms is the resolver for the rooms field.
func (r *queryResolver) Rooms(ctx context.Context) ([]*model.Room, error) {
	panic(fmt.Errorf("not implemented: Rooms - rooms"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
